<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>A* Pathfinding Demo</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                height: 100vh;
                background-color: #f4f4f4;
            }

            .flex {
                display: flex;
            }

            .modeMenu {
                display: flex;
                flex-direction: column;
                align-items: end;
            }

            .grid {
                display: grid;
                grid-template-columns: repeat(10, minmax(9vh, 1fr));
                grid-gap: 2px;
                box-sizing: border-box;
                user-select: none;
            }

            .cell {
                aspect-ratio: 1 / 1;
                border: 1px solid #000;
                position: relative;
            }

            .cell.end {
                background-color: red;
                color: white;
            }

            .cell.open {
                background-color: rgba(0, 128, 0, 0.5);
            }

            .cell.closed {
                background-color: rgba(255, 0, 0, 0.25);
            }

            .cell.start {
                background-color: blue;
                color: white;
            }

            .cell.path {
                background-color: forestgreen;
            }

            .cell.blocked {
                background-color: black;
            }

            .icons {
                position: absolute;
                bottom: 0;
                display: none;
                width: 100%;
                justify-content: space-around;
                background: rgba(255, 255, 255, 0.7);
                padding: 2px;
            }

            .grid:not(.startMode):not(.endMode):not(.blockMode) .cell:hover .icons {
                display: flex;
            }

            .icon {
                cursor: pointer;
                font-size: 12px;
            }

            .blockMode .cell {
                cursor: cell;
            }

            .startMode .cell,
            .endMode .cell
            {
                cursor: alias;
            }
        </style>
    </head>

    <body>
        <div class="flex">
            <div class="modeMenu">
                Mode
                <span><label for="default">‚ú≥0<input id="defaultMode" name="mode" type="radio" value="default"></label></span>
                <span><label for="startMode">‚≠ê1<input id="startMode" name="mode" type="radio" value="startMode"></label></span>
                <span><label for="endMode">üèÅ2<input id="endMode" name="mode" type="radio" value="endMode"></label></span>
                <span><label for="blockMode">üè¥3<input id="blockMode" name="mode" type="radio" value="blockMode" checked></label></span>
            </div>
            <div class="grid" id="grid"></div>
        </div>
        <div>
            <button id="nextStep">Next step</button>
            <button id="complete">Complete</button>
            <button id="clearAll">Clear All</button>
        </div>
        <script>
            function switchMode(mode) {
                grid.classList.remove('startMode', 'endMode', 'blockMode');
                mode && grid.classList.add(mode);
            }
            var defaultMode = document.getElementById('defaultMode');
            var startMode = document.getElementById('startMode');
            var endMode = document.getElementById('endMode');
            var blockMode = document.getElementById('blockMode');

            defaultMode.onchange = () => switchMode('');
            startMode.onchange = () => switchMode('startMode');
            endMode.onchange = () => switchMode('endMode');
            blockMode.onchange = () => switchMode('blockMode');

            document.onkeypress = function (e) {
                [defaultMode, startMode, endMode, blockMode][e.key]?.click();
            }

            const gridSize = 10;
            const start = { x: 0, y: 0 };
            const end = { x: 9, y: 9 };
            const grid = document.getElementById("grid");
            const cells = Array.from(Array(gridSize), () => Array(gridSize).fill());
            const blockedCells = [
                [2, 0], [8, 0],
                [4, 1], [7, 1],
                [0, 2], [3, 2], [6, 2],
                [2, 3], [5, 3], [8, 3],
                [1, 4], [7, 4],
                [3, 5], [6, 5], [9, 5],
                [2, 6], [5, 6], [8, 6],
                [1, 7], [4, 7],
                [0, 8], [3, 8], [6, 8], [8, 8],
                [5, 9]
            ].map(([x, y]) => ({ x, y }));

            function createGrid() {
                cells.forEach((col, y) => {
                    col.forEach((_, x, array) => {
                        const cell = document.createElement("div");
                        cell.classList.add("cell");
                        cell.dataset.x = x;
                        cell.dataset.y = y;

                        const data = document.createElement("div");
                        data.classList.add("data");

                        const icons = document.createElement("div");
                        icons.classList.add("icons");
                        icons.innerHTML = '<span class="icon">‚≠ê</span><span class="icon">üèÅ</span><span class="icon">üè¥</span>';

                        icons.children[0].addEventListener("click", () => setStart(x, y));
                        icons.children[1].addEventListener("click", () => setEnd(x, y));
                        icons.children[2].addEventListener("click", () => toggleBlock(x, y));

                        cell.appendChild(data);
                        cell.appendChild(icons);
                        grid.appendChild(cell);
                        array[x] = cell;
                    });
                });
                cells[start.y][start.x].classList.add("start");
                cells[end.y][end.x].classList.add("end");
                blockedCells.forEach(({ x, y }) => cells[y][x].classList.add("blocked"));
            }

            function heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }

            function getNeighbors(node) {
                return [
                    { x: node.x + 1, y: node.y },
                    { x: node.x - 1, y: node.y },
                    { x: node.x, y: node.y + 1 },
                    { x: node.x, y: node.y - 1 }
                ].filter(n => n.x >= 0
                    && n.y >= 0
                    && n.x < gridSize
                    && n.y < gridSize
                    && !cells[n.y][n.x].classList.contains("blocked"))
            }

            function findPath(start, end) {
                let numSteps = 0;
                const openSet = [{ x: start.x, y: start.y, g: 0, h: heuristic(start, end), f: 0, parent: null }];
                const closedSet = [];

                function restart() {
                    numSteps = 0;
                    openSet.splice(0);
                    openSet.push({ x: start.x, y: start.y, g: 0, h: heuristic(start, end), parent: null });
                    closedSet.splice(0);

                    [...document.getElementsByClassName('cell')].forEach(e => e.classList.remove('open', 'closed'));
                    cells[start.y][start.x].classList.add('open');

                    for (const cell of document.getElementsByClassName('data')) {
                        cell.innerText = '';
                        cell.parentNode.classList.remove('path');
                    }
                }

                return {
                    restart,
                    setStart: function (x, y) {
                        cells[start.y][start.x].classList.remove('start');
                        start = { x: +x, y: +y };
                        cells[start.y][start.x].classList.add('start');
                        restart();
                    },
                    setEnd: function (x, y) {
                        cells[end.y][end.x].classList.remove('end');
                        end = { x: +x, y: +y };
                        cells[end.y][end.x].classList.add('end');
                        restart();
                    },
                    next: function () {
                        numSteps++;
                        if (openSet.length === 0) {
                            alert('No solution found');
                            return 'done';
                        } else {
                            openSet.sort((a, b) => a.f - b.f || a.h - b.h);
                            const current = openSet.shift();
                            closedSet.push(current);

                            var cell = cells[current.y][current.x]
                            cell.classList.remove('open');
                            cell.classList.add('closed');

                            if (current.x === end.x && current.y === end.y) {
                                for (let parent = current.parent; parent; parent = parent.parent) {
                                    cells[parent.y][parent.x].classList.add("path");
                                }
                                alert(`Solution found in ${numSteps} steps.`);
                                return 'done';
                            } else {
                                for (const neighbor of getNeighbors(current)) {
                                    if (!closedSet.some(c => c.x === neighbor.x && c.y === neighbor.y)) {
                                        const g = current.g + 1;
                                        const h = heuristic(neighbor, end);
                                        const f = g + h;
                                        const existing = openSet.find(c => c.x === neighbor.x && c.y === neighbor.y);

                                        if (!existing || g < existing.g) {
                                            openSet.push({ ...neighbor, g, h, f, parent: current });
                                            cells[neighbor.y][neighbor.x].querySelector('.data').innerText = `G:${g}\nH:${h}\nF:${f}`;
                                            cells[neighbor.y][neighbor.x].classList.add('open');
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            createGrid();
            var astar = findPath(start, end);

            function setStart(x, y) {
                astar.setStart(x, y);
            }

            function setEnd(x, y) {
                astar.setEnd(x, y);
            }

            function toggleBlock(x, y) {
                const classes = cells[y][x].classList;
                if (classes.contains('blocked')) {
                    classes.remove('blocked');
                } else {
                    classes.add('blocked');
                }
                astar.restart();
            }

            document.getElementById('nextStep').onclick = astar.next;
            document.getElementById('complete').onclick = () => { while (astar.next() !== 'done'); };
            document.getElementById('clearAll').onclick = function () {
                var blockedCells = [...document.getElementsByClassName('blocked')];
                for (var cell of blockedCells) {
                    cell.classList.remove('blocked');
                }
                astar.restart();
            };
            grid.onmousedown = function(e) {
                var cell = e.target.closest('.cell');
                if (cell && e.buttons === 1) {
                    if (grid.classList.contains('blockMode')
                        && cell.classList.contains('cell'))
                    {
                        astar.restart();
                        if (cell.classList.contains('blocked')) {
                            cell.classList.remove('blocked');
                            startUnblockingTiles();
                        } else {
                            cell.classList.add('blocked');
                            startBlockingTiles();
                        }
                    } else if (grid.classList.contains('startMode')) {
                        setStart(cell.dataset.x, cell.dataset.y);
                        startMarkStart();
                    } else if (grid.classList.contains('endMode')) {
                        setEnd(cell.dataset.x, cell.dataset.y);
                        startMarkFinish();
                    }
                }
            }
            grid.onmouseup = function() { grid.onmouseover = null; }
            grid.onmouseleave = function() { grid.onmouseover = null; }
            function startBlockingTiles() {
                grid.onmouseover = function(e) {
                    if (e.target.classList.contains('cell') && !e.target.classList.contains('blocked')) {
                        e.target.classList.add('blocked');
                    }
                }
            }
            function startUnblockingTiles() {
                grid.onmouseover = function(e) {
                    if (e.target.classList.contains('cell') && e.target.classList.contains('blocked')) {
                        e.target.classList.remove('blocked');
                    }
                }
            }
            function startMarkStart() {
                grid.onmouseover = function (e) {
                    if (e.target.classList.contains('cell')) {
                        setStart(e.target.dataset.x, e.target.dataset.y);
                    }
                }
            }
            function startMarkFinish() {
                grid.onmouseover = function (e) {
                    if (e.target.classList.contains('cell')) {
                        setEnd(e.target.dataset.x, e.target.dataset.y);
                    }
                }
            }

            document.querySelector(':checked').onchange();
        </script>
    </body>

</html>