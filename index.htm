<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>A* Pathfinding Demo</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                height: 100vh;
                background-color: #f4f4f4;
            }

            .flex {
                display: flex;
            }

            .col {
                flex-direction: column;
            }

            .controls {
                width: 100%;
                align-self: stretch;
                display: flex;
                overflow: hidden;

                button {
                    flex-grow: 1;
                    aspect-ratio: 1;
                }
            }

            .hide {
                display: none;
            }

            .grid {
                display: grid;
                grid-template-columns: repeat(10, minmax(9vh, 1fr));
                box-sizing: border-box;
                user-select: none;
            }

            .cell {
                aspect-ratio: 1 / 1;
                border: 1px solid #000;
                position: relative;
                overflow: hidden;
                transition: background-color 0.1s ease;
            }

            .arrow {
                display: none;
                rotate: var(--angle);
                text-align: center;
                transition: rotate 0.5s ease;
            }

            .cell .data:not(:empty)+.arrow {
                display: block;
            }

            .cell.end {
                background-color: red;
                color: white;
            }

            .cell.open {
                background-color: rgb(255, 230, 155);
            }

            .cell.closed {
                background-color: rgba(255, 0, 0, 0.25);
            }

            .cell.start {
                background-color: blue;
                color: white;
            }

            @keyframes pathComplete {
                0% {
                    background-color: rgba(255, 0, 0, 0.25)
                }

                10% {
                    background-color: #fff;
                }

                100% {
                    background-color: #0eac44;
                }
            }

            .cell.path,
            .cell.end.closed {
                animation: 1s ease-in 0s 1 forwards running pathComplete;

                body:has(#completeButton:disabled) & {
                    animation-duration: 0s;
                }
            }

            .cell.blocked {
                background-color: black;
            }

            .blockMode .cell {
                cursor: cell;
            }

            .startMode .cell,
            .endMode .cell {
                cursor: alias;
            }
        </style>
    </head>

    <body>
        <input id="startCell" type="hidden" value="[0, 0]">
        <input id="endCell" type="hidden" value="[9, 9]">
        <input id="blockedCells" type="hidden"
            value="[[3, 0], [3, 1], [3, 2], [3, 3], [7, 4], [7, 5], [7, 6], [4, 7], [5, 7], [6, 7], [7, 7]]">
        <div class="flex">
            <div class="flex col">
                <div class="controls">
                    <button id="stepButton" value="step" title="Step">‚èØ</button>
                    <button id="pauseButton" class="hide" value="pause" title="Pause">‚è∏</button>
                    <button id="playButton" value="play" title="Play">‚ñ∂</button>
                    <button id="completeButton" value="complete" title="Autocomplete">‚è≠</button>
                </div>
                <div class="flex col">
                    <label for="modeSelect">Cursor Mode:</label>
                    <select id="modeSelect" size="3">
                        <option value="startMode">‚≠ê Mark start (1)</option>
                        <option value="endMode">üèÅ Mark end (2)</option>
                        <option value="blockMode" selected="">üè¥ Block (3)</option>
                    </select>
                </div>
                <div>
                    <label for="neighborsSelect">Neighbors:</label>
                    <select id="neighborsSelect">
                        <option value="4" selected="">4</option>
                        <option value="8">8</option>
                    </select>
                </div>
                <div>
                    <label for="heuristicSelect">Heuristic:</label>
                    <select id="heuristicSelect">
                        <option value="steps" selected="">Steps</option>
                        <option value="distance">Distance</option>
                    </select>
                </div>
            </div>
            <div class="grid" id="grid"></div>
        </div>
        <script>
            function setCursorMode(mode) {
                grid.classList.remove('startMode', 'endMode', 'blockMode');
                grid.classList.add(mode);
            }

            document.onkeypress = function (e) {
                const option = modeSelect.children[e.key - 1]
                if (option) {
                    option.selected = true;
                    modeSelect.dispatchEvent(new Event('change'));
                }
            }

            const gridSize = 10;
            const [startX, startY] = JSON.parse(document.getElementById('startCell').value);
            const [endX, endY] = JSON.parse(document.getElementById('endCell').value);
            const start = { x: +startX, y: +startY };
            const end = { x: +endX, y: +endY };
            const grid = document.getElementById('grid');
            const cells = Array.from(Array(gridSize), () => Array(gridSize).fill());
            const blockedCells = JSON.parse(document.getElementById('blockedCells').value).map(([x, y]) => ({ x, y }));

            function createGrid() {
                cells.forEach((col, y) => {
                    col.forEach((_, x, array) => {
                        const cell = document.createElement("div");
                        cell.classList.add("cell");
                        cell.dataset.x = x;
                        cell.dataset.y = y;

                        const data = document.createElement("div");
                        data.classList.add("data");

                        const arrow = document.createElement("div");
                        arrow.classList.add("arrow");
                        arrow.append('‚¨Ü');

                        cell.appendChild(data);
                        cell.appendChild(arrow);
                        grid.appendChild(cell);
                        array[x] = cell;
                    });
                });
                cells[start.y][start.x].classList.add("start");
                cells[end.y][end.x].classList.add("end");
                blockedCells.forEach(({ x, y }) => cells[y][x].classList.add("blocked"));
            }

            function stepHeuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }

            function distanceHeuristic(a, b) {
                const offset = [a.x - b.x, a.y - b.y];
                return Math.sqrt(offset[0] * offset[0] + offset[1] * offset[1]);
            }

            function getAdjacentNeighbors(node) {
                return [
                    { x: node.x + 1, y: node.y },
                    { x: node.x - 1, y: node.y },
                    { x: node.x, y: node.y + 1 },
                    { x: node.x, y: node.y - 1 }
                ].filter(n => n.x >= 0
                    && n.y >= 0
                    && n.x < gridSize
                    && n.y < gridSize
                    && !cells[n.y][n.x].classList.contains("blocked"))
            }

            function getAllNeighbors(node) {
                return [
                    { x: node.x + 1, y: node.y },
                    { x: node.x - 1, y: node.y },
                    { x: node.x, y: node.y + 1 },
                    { x: node.x, y: node.y - 1 },
                    { x: node.x + 1, y: node.y + 1 },
                    { x: node.x + 1, y: node.y - 1 },
                    { x: node.x - 1, y: node.y - 1 },
                    { x: node.x - 1, y: node.y + 1 }
                ].filter(n => n.x >= 0
                    && n.y >= 0
                    && n.x < gridSize
                    && n.y < gridSize
                    && !cells[n.y][n.x].classList.contains("blocked"))
            }

            let getNeighbors = neighborsSelect.value === '8' ? getAllNeighbors : getAdjacentNeighbors;
            let heuristic = heuristicSelect.value === 'steps' ? stepHeuristic : distanceHeuristic;

            function findPath(start, end) {
                let startCell = cells[start.y][start.x];
                let endCell = cells[end.y][end.x];
                let numSteps = 0;
                let completed = false;
                const openSet = [{ x: start.x, y: start.y, g: 0, h: heuristic(start, end), f: 0, parent: null }];
                const closedSet = [];

                function restart() {
                    completed = false;
                    numSteps = 0;
                    openSet.splice(0);
                    openSet.push({ x: start.x, y: start.y, g: 0, h: heuristic(start, end), parent: null });
                    closedSet.splice(0);

                    [...document.getElementsByClassName('cell')].forEach(e => e.classList.remove('open', 'closed'));
                    startCell.classList.add('open');

                    for (const cell of document.getElementsByClassName('data')) {
                        cell.innerText = '';
                        cell.parentNode.classList.remove('path');
                    }
                }

                return {
                    restart,
                    isComplete: function () { return completed || !openSet.length; },
                    setStart: function (x, y) {
                        startCell.classList.remove('start');
                        start = { x: +x, y: +y };
                        startCell = cells[y][x];
                        startCell.classList.add('start');
                        restart();
                    },
                    setEnd: function (x, y) {
                        endCell.classList.remove('end');
                        end = { x: +x, y: +y };
                        endCell = cells[y][x];
                        endCell.classList.add('end');
                        restart();
                    },
                    next: function () {
                        if (!completed && openSet.length) {
                            numSteps++;
                            openSet.sort((a, b) => a.f - b.f || a.h - b.h);
                            const current = openSet.shift();
                            closedSet.push(current);

                            var cell = cells[current.y][current.x];
                            cell.classList.remove('open');
                            cell.classList.add('closed');

                            if (current.x === end.x && current.y === end.y) {
                                for (let parent = current.parent; parent; parent = parent.parent) {
                                    cells[parent.y][parent.x].classList.add("path");
                                }
                                completed = true;
                            } else {
                                for (const neighbor of getNeighbors(current)) {
                                    if (!closedSet.some(c => c.x === neighbor.x && c.y === neighbor.y)) {
                                        const g = current.g + distanceHeuristic(current, neighbor);
                                        const h = heuristic(neighbor, end);
                                        const f = g + h;
                                        const existing = openSet.find(c => c.x === neighbor.x && c.y === neighbor.y);
                                        const neighborCell = cells[neighbor.y][neighbor.x];

                                        if (!existing) {
                                            const parentAngle = Math.atan2(neighbor.y - current.y, neighbor.x - current.x) - 0.5 * Math.PI;
                                            neighborCell.style = `--angle:${parentAngle}rad`
                                            openSet.push({ ...neighbor, g, h, f, parent: current });
                                            neighborCell.querySelector('.data').innerText = `G:${g.toFixed(2)}\nH:${h.toFixed(2)}\nF:${f.toFixed(2)}`;
                                            neighborCell.classList.add('open');
                                        } else if (g < existing.g) {
                                            const parentAngle = Math.atan2(neighbor.y - current.y, neighbor.x - current.x) - 0.5 * Math.PI;
                                            neighborCell.style = `--angle:${parentAngle}rad`
                                            existing.g = g;
                                            existing.h = h;
                                            existing.f = f;
                                            existing.parent = current;
                                            neighborCell.querySelector('.data').innerText = `G:${g.toFixed(2)}\nH:${h.toFixed(2)}\nF:${f.toFixed(2)}`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            createGrid();
            var astar = findPath(start, end);

            function setStart(x, y) {
                astar.setStart(x, y);

                if (completeButton.disabled) {
                    autoComplete();
                }
            }

            function setEnd(x, y) {
                astar.setEnd(x, y);

                if (completeButton.disabled) {
                    autoComplete();
                }
            }

            function toggleBlock(x, y) {
                cells[y][x].classList.toggle('blocked');
                astar.restart();
            }

            function startAutoComplete() {
                if (autoplayInterval) {
                    clearInterval(autoplayInterval);
                    autoplayInterval = null;
                }
                playButton.classList.remove('hide');
                pauseButton.classList.add('hide');
                completeButton.disabled = true;
                autoComplete();
            }

            function autoComplete() {
                while (!astar.isComplete()) {
                    astar.next();
                }
            }

            grid.onmousedown = function (e) {
                var cell = e.target.closest('.cell');
                if (cell && e.buttons === 1) {
                    if (grid.classList.contains('blockMode')
                        && cell.classList.contains('cell')) {
                        if (cell.classList.toggle('blocked')) {
                            startBlockingTiles();
                        } else {
                            startUnblockingTiles();
                        }
                        astar.restart();
                        if (completeButton.disabled) {
                            startAutoComplete();
                        }
                    } else if (grid.classList.contains('startMode')) {
                        setStart(cell.dataset.x, cell.dataset.y);
                        startMarkStart();
                    } else if (grid.classList.contains('endMode')) {
                        setEnd(cell.dataset.x, cell.dataset.y);
                        startMarkFinish();
                    }
                }
            }
            document.onmouseup = function () { grid.onmouseover = null; }
            function startBlockingTiles() {
                grid.onmouseover = function (e) {
                    var cell = e.target.closest('.cell');
                    if (cell && !cell.classList.contains('blocked')) {
                        cell.classList.add('blocked');
                        astar.restart();
                        if (completeButton.disabled) {
                            startAutoComplete();
                        }
                    }
                }
            }
            function startUnblockingTiles() {
                grid.onmouseover = function (e) {
                    var cell = e.target.closest('.cell');
                    if (cell && cell.classList.contains('blocked')) {
                        cell.classList.remove('blocked');
                        astar.restart();
                        if (completeButton.disabled) {
                            startAutoComplete();
                        }
                    }
                }
            }
            function startMarkStart() {
                grid.onmouseover = function (e) {
                    var cell = e.target.closest('.cell');
                    if (cell) {
                        setStart(cell.dataset.x, cell.dataset.y);
                    }
                }
            }
            function startMarkFinish() {
                grid.onmouseover = function (e) {
                    var cell = e.target.closest('.cell');
                    if (cell) {
                        setEnd(cell.dataset.x, cell.dataset.y);
                    }
                }
            }

            stepButton.onclick = function () {
                if (autoplayInterval) {
                    clearInterval(autoplayInterval);
                    autoplayInterval = null;
                }
                playButton.classList.remove('hide');
                pauseButton.classList.add('hide');
                completeButton.disabled = false;
                if (astar.isComplete()) {
                    astar.restart();
                }
                astar.next();
            }

            let autoplayInterval = null;
            playButton.onclick = function startAutoplay() {
                playButton.classList.add('hide');
                pauseButton.classList.remove('hide');
                completeButton.disabled = false;
                if (autoplayInterval) {
                    clearInterval(autoplayInterval);
                }
                if (astar.isComplete()) {
                    astar.restart();
                }
                autoplayInterval = setInterval(function () {
                    if (!astar.isComplete()) {
                        astar.next();
                    } else {
                        clearInterval(autoplayInterval);
                        autoplayInterval = setInterval(startAutoplay, 2000);
                    }
                }, 100);
            }

            pauseButton.onclick = function () {
                if (autoplayInterval) {
                    clearInterval(autoplayInterval);
                    autoplayInterval = null;
                }
                playButton.classList.remove('hide');
                pauseButton.classList.add('hide');
            }

            completeButton.onclick = startAutoComplete;

            modeSelect.onchange = function (e) {
                setCursorMode(e.target.value);
            }
            neighborsSelect.onchange = function (e) {
                getNeighbors = e.currentTarget.value === '8' ? getAllNeighbors : getAdjacentNeighbors;

                astar.restart()
                if (completeButton.disabled) {
                    autoComplete();
                }
            }
            heuristicSelect.onchange = function (e) {
                heuristic = e.currentTarget.value === 'steps' ? stepHeuristic : distanceHeuristic;

                astar.restart()
                if (completeButton.disabled) {
                    autoComplete();
                }
            }

            window.onbeforeunload = function () {
                document.getElementById('startCell').value = JSON.stringify(Object.entries(document.getElementsByClassName('start')[0].dataset).map(([, i]) => i));
                document.getElementById('endCell').value = JSON.stringify(Object.entries(document.getElementsByClassName('end')[0].dataset).map(([, i]) => i));
                document.getElementById('blockedCells').value = JSON.stringify([...document.getElementsByClassName('blocked')].map(e => [+e.dataset.x, +e.dataset.y]));
            }

            setCursorMode(modeSelect.value);
        </script>
    </body>

</html>